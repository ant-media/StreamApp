<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8" />
    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
      integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh"
      crossorigin="anonymous"
    />
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
    <script src="js/webrtc_adaptor.js"></script>
    <style>
      .inbox_chat {
        height: 550px;
        overflow-y: scroll;
      }

      .active_chat {
        background: #ebebeb;
      }

      .received_img {
        width: 80%;
        float: left;
        padding: 0 0 0 10px;
      }

      .sent_img {
        padding: 10px 0 0 0;
        float: right;
        width: 80%;
      }

      .received_msg {
        display: inline-block;
        padding: 0 0 0 10px;
        vertical-align: top;
        width: 92%;
      }

      .received_withd_msg p {
        background: #f0e68c none repeat scroll 0 0;
        border-radius: 3px;
        color: #646464;
        font-size: 14px;
        margin: 0;
        padding: 5px 10px 5px 12px;
        width: 100%;
      }

      .time_date {
        color: #747474;
        display: block;
        font-size: 12px;
        margin: 8px 0 0;
      }

      .received_withd_msg {
        float: left;
      }

      .mesgs {
        float: left;
        padding: 30px 15px 0 25px;
        width: 90%;
        overflow-y: scroll;
      }

      .sent_msg p {
        background: #05728f none repeat scroll 0 0;
        border-radius: 3px;
        font-size: 14px;
        margin: 0;
        color: #fff;
        padding: 5px 10px 5px 12px;
        width: 100%;
      }

      .outgoing_msg {
        overflow: hidden;
        margin: 26px 0 26px;
      }

      .sent_msg {
        float: right;
      }

      .type_msg {
        border-top: 1px solid #c4c4c4;
        position: relative;
      }

      .messaging {
        padding: 0 0 50px 0;
      }

      .msg_history {
        height: 300px;
        overflow-y: auto;
      }
      video {
        object-fit: cover;
      }
    </style>
  </head>

  <body>
    <div class="container" style="padding: 40px 15px; text-align: center">
      <div class="header clearfix">
        <div class="row">
          <ul class="nav float-right">
            <h3 class="col text-muted">WebRTC Data Channel Example</h3>
          </ul>
          <nav class="col align-self-center">
            <ul class="nav float-right">
              <li><a href="http://antmedia.io">Contact</a></li>
            </ul>
          </nav>
        </div>
      </div>
      <div class="jumbotron">
        <div class="col-sm-12 form-group">
          <div class="form-row d-flex justify-content-center">
            <div class="form-group col-sm-6" id="localVideoDiv">
              <video
                id="localVideo"
                autoplay
                muted
                width="480"
                height="480"
              ></video>
            </div>
            <div class="form-group col-sm-6" id="remoteVideoDiv">
              <video
                id="remoteVideo"
                autoplay
                controls
                width="480"
                height="480"
              ></video>
            </div>
          </div>
        </div>
        <br />
        <br />
        <div class="form-group col-sm-12 text-left">
          <div class="form-row">
            <div class="form-group col-sm-8">
              <input
                type="text"
                class="form-control"
                value="stream1"
                id="streamName"
                placeholder="Type stream name"
              />
            </div>
            <div class="form-group col-sm-2">
              <button
                type="button"
                class="btn btn-outline-primary btn-block"
                onclick="start()"
                id="start_button"
              >
                Start
              </button>
            </div>
            <div class="form-group col-sm-2">
              <button
                type="button"
                class="btn btn-outline-primary btn-block"
                onclick="stop()"
                disabled
                id="stop_button"
              >
                Stop
              </button>
            </div>
          </div>
        </div>
        <div class="form-group col-sm-12 text-center options">
          <div class="row">
            <div class="col-md-12 col-md-offset-3">
              <h2 text-align:center>Chat Window</h2>
            </div>
          </div>
        </div>
        <div class="form-group col-sm-12 text-left options">
          <div class="form-row">
            <div class="form-group col-sm-12">
              <div class="mesgs">
                <div id="all_messages" class="msg_history container"></div>
              </div>
            </div>
          </div>
          <div class="form-row">
            <div class="form-group col-sm-8">
              <input
                type="text"
                class="form-control"
                id="dataTextbox"
                placeholder="Write your message to send players"
              />
            </div>
            <div class="form-group col-sm-2">
              <button
                type="button"
                class="btn btn-outline-primary btn-block"
                onclick="sendText()"
              >
                Send
              </button>
            </div>
            <div class="form-group col-sm-2">
              <button
                type="button"
                class="btn btn-outline-primary btn-block"
                onclick="document.getElementById('file-input').click();"
              >
                Send Image
              </button>
              <input
                id="file-input"
                type="file"
                name="name"
                onchange="send_image()"
                accept="image/x-png,image/gif,image/jpeg"
                style="display: none"
              />
            </div>
          </div>
        </div>
      </div>
    </div>
    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
      crossorigin="anonymous"
    ></script>
  </body>

  <script>
    function getUrlParameter(sParam) {
      var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split("&"),
        sParameterName,
        i;

      for (i = 0; i < sURLVariables.length; i++) {
        sParameterName = sURLVariables[i].split("=");

        if (sParameterName[0] === sParam) {
          return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      }
    }

    var mode = getUrlParameter("mode");
    var local_video = document.getElementById("localVideoDiv");
    var remote_video = document.getElementById("remoteVideoDiv");

    if (mode !== "publish" && mode !== "play" && mode !== "peer") {
      console.log("mode is invalid, setting mode to peer");
      mode = "peer";
    } else if (mode == "play") {
      console.log("setting mode to play");
      local_video.style.display = "none";
      local_video.style.margin = "auto";
    } else if (mode == "publish") {
      console.log("setting mode to publish");
      remote_video.style.display = "none";
      remote_video.style.margin = "auto";
    } else if (mode == "peer") {
      console.log("setting mode to peer");
    }

    /**
     * If publishing stops for any reason, it tries to republish again.
     */
    var autoRepublishEnabled = true;
    /**
     * Timer job that checks the WebRTC connection
     */
    var autoRepublishIntervalJob = null;

    var file_input = document.getElementById("file-input");
    var start_button = document.getElementById("start_button");
    var stop_button = document.getElementById("stop_button");


    var token = "<%= request.getParameter("token") %>";
    var streamNameBox = document.getElementById("streamName");
    var imageSender = new BinaryDataSender();
    var imageReceiver = new BinaryDataReceiver();

    var messageNumber = 0;
    var idBody = "browser";

    function BinaryDataSender() {
      this.sending = false;
      this.endChunk = 0;
      this.lastOffset = 0;
      this.dataBytes = null;
      this.CHUNK_SIZE_IN_BYTES = 10000;
      this.headerText = null;
      this.headerLength = 0;
      this.textEncoder = new TextEncoder();

      var thiz = this;

      this.isDataSendingComplete = function () {
        return thiz.lastOffset >= thiz.dataBytes.byteLength;
      };

      this.clear = function () {
        thiz.sending = false;
        thiz.lastOffset = 0;
        thiz.endChunk = 0;
        thiz.dataBytes = null;
        thiz.headerText = null;
        thiz.headerLength = 0;
      };

      this.startSending = function (dataBytesTemp, messageHeader) {
        thiz.sending = true;
        thiz.lastOffset = 0;
        thiz.dataBytes = dataBytesTemp;
        thiz.sendFirstChunk(messageHeader);
      };

      this.sendFirstChunk = function (messageHeader) {
        thiz.headerText = messageHeader;

        var encodedText = thiz.textEncoder.encode(messageHeader);
        var encodedTextBuffer = encodedText.buffer;

        thiz.headerLength = encodedTextBuffer.byteLength;
        var totalMessageHeaderLength = thiz.headerLength + 8;

        var remainingChunkSize =
          thiz.CHUNK_SIZE_IN_BYTES - totalMessageHeaderLength;

        thiz.endChunk =
          thiz.lastOffset + remainingChunkSize > thiz.dataBytes.byteLength
            ? thiz.dataBytes.byteLength
            : thiz.lastOffset + remainingChunkSize;

        // put length how much data will be sent in total
        var buffer = new ArrayBuffer(totalMessageHeaderLength + thiz.endChunk);
        var view = new Int32Array(buffer);
        view[0] = thiz.dataBytes.byteLength;
        view[1] = thiz.headerLength;
        console.log(
            "Total to be sent data length:",
            view[0]
          );
          console.log(
            "Message header length:",
            view[0]
          );
        // copy encoded header text to buffer byte by byte
        var bufferView = new Uint8Array(buffer, 0, buffer.byteLength);
        bufferView.set(encodedText, 8);

        // copy image slice
        var imageSlice = thiz.dataBytes.slice(0, thiz.endChunk);
        bufferView.set(new Uint8Array(imageSlice), totalMessageHeaderLength);

        sendData(buffer);
        thiz.lastOffset = thiz.endChunk;
      };

      this.sendLastChunk = function () {
        thiz.endChunk =
          thiz.lastOffset + thiz.CHUNK_SIZE_IN_BYTES > thiz.dataBytes.byteLength
            ? thiz.dataBytes.byteLength
            : thiz.lastOffset + thiz.CHUNK_SIZE_IN_BYTES;

        var imageSlice = thiz.dataBytes.slice(thiz.lastOffset, thiz.endChunk);

        sendData(imageSlice);
        thiz.lastOffset = thiz.endChunk;

      };
    }

    function BinaryDataReceiver() {
      this.toBeReceivedTotalLength = 0;
      this.receivedData = null;
      this.headerText = null;
      this.headerLength = 0;
      this.textDecoder = new TextDecoder("utf-8");

      var thiz = this;

      this.clear = function () {
        thiz.toBeReceivedTotalLength = 0;
        thiz.receivedData = null;
        thiz.headerText = null;
        thiz.headerLength = 0;
      };

      this.isFirstPart = function () {
        return thiz.receivedData === null;
      };

      this.isAllDataReceived = function () {
        return thiz.receivedData.byteLength >= thiz.toBeReceivedTotalLength;
      };

      this.appendBuffer = function (buffer1, buffer2) {
        var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
        tmp.set(new Uint8Array(buffer1), 0);
        tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
        return tmp.buffer;
      };

      this.receiveDataChunk = function (dataChunk) {
        // handle binary data
        if (!thiz.isFirstPart()) {
          thiz.receivedData = thiz.appendBuffer(thiz.receivedData, dataChunk);
        } else {
          var dataView = new DataView(dataChunk);
          thiz.toBeReceivedTotalLength = dataView.getInt32(0,true);
          thiz.headerLength = dataView.getInt32(4, true);
          var totalHeaderLength = thiz.headerLength + 8;

          var headerSlice = dataChunk.slice(8, totalHeaderLength);
          var headerSliceView = new Uint8Array(headerSlice);
          thiz.headerText = thiz.textDecoder.decode(headerSliceView);

          console.log(
            "Total to be received data length:",
            thiz.toBeReceivedTotalLength
          );
          console.log(
            "Total header length:",
            thiz.headerLength
          );
          thiz.receivedData = dataChunk.slice(totalHeaderLength);
        }
      };
    }

    function createId() {
      return idBody + messageNumber;
    }

    function send_image() {
      var imageURL = file_input.files[0];

      var reader = new FileReader();
      reader.onload = function (e) {
        var arrayBuffer = this.result;
        var bytes = new Uint8Array(arrayBuffer);
        var blob = new Blob([bytes.buffer]);
        var urlCreator = window.URL || window.webkitURL;
        var imageBlobUrl = urlCreator.createObjectURL(blob);

        var date = new Date();
        var dateTime = date.getTime();
        var messageHeader = { messageId: createId(), messageDate: dateTime };
        imageSender.startSending(arrayBuffer, JSON.stringify(messageHeader));

        send_image_chunkwise();

        createImageMessage(imageBlobUrl, true, date.toLocaleTimeString());
      };

      reader.readAsArrayBuffer(imageURL);
    }

    async function send_image_chunkwise() {
      while (!imageSender.isDataSendingComplete()) {
        imageSender.sendLastChunk();
        //await new Promise(r => setTimeout(r, 1));
      }
    }

    function createImageMessage(imageURL, sentByUs, date) {
      if (sentByUs) {
        $(
          '<div class="outgoing_msg row"><div class="col"> <div class="rounded float-right sent_img"><img class="img-fluid "  src =' +
            imageURL +
            '><span class="time_date">' +
            date +
            "</span></div></div></div>"
        ).appendTo($("#all_messages"));
      } else {
        $(
          '<div class="incoming_msg row"><div class="col"><div class="rounded float-left received_img"><img class="img-fluid"  src =' +
            imageURL +
            '><span class="time_date">' +
            date +
            "</span></div></div></div>"
        ).appendTo($("#all_messages"));
      }
    }

    function sendText() {
      var text = $("#dataTextbox").val();
      var dateObj = new Date();
      var dateTime = dateObj.getTime();

      var messageObject = {
        messageId: createId(),
        messageDate: dateTime,
        messageBody: text,
      };

      sendData(JSON.stringify(messageObject));

      createNewMessage(text, dateObj.toLocaleTimeString(), true);
      $("#dataTextbox").val("");
    }

    function createNewMessage(message, date, sentByUs) {
      if ($.trim(message) == "") {
        return false;
      }
      if (sentByUs) {
        $(
          '<div class="outgoing_msg row"><div class="col"><div class="sent_msg">	<p>' +
            message +
            '</p><span class="time_date">' +
            date +
            "</span></div></div></div>"
        ).appendTo($("#all_messages"));
      } else {
        $(
          '<div class="incoming_msg row"><div class="col" ><div class="received_msg"><div class="received_withd_msg"><p>' +
            message +
            '</p><span class="time_date">' +
            date +
            "</span></div></div></div>"
        ).appendTo($("#all_messages"));
      }
    }

    function start() {
      if(mode == "publish") {
        startPublishing();
      } else if(mode == "play") {
        startPlaying();
      } else {
        join();
      }
    }
    function stop() {
      if(mode == "publish") {
        stopPublishing();
      } else if(mode == "play") {
        stopPlaying();
      } else {
        leave();
      }     
    }
    function join() {
      webRTCAdaptor.join(streamNameBox.value);
    }

    function leave() {
      webRTCAdaptor.leave(streamNameBox.value);
    }

    function startPublishing() {
      streamId = streamNameBox.value;
      webRTCAdaptor.publish(streamId, token);
    }

    function stopPublishing() {
      if (autoRepublishIntervalJob != null) {
        clearInterval(autoRepublishIntervalJob);
        autoRepublishIntervalJob = null;
      }
      webRTCAdaptor.stop(streamId);
    }

    function startPlaying() {
      streamId = streamNameBox.value;
      webRTCAdaptor.play(streamNameBox.value, token);
    }

    function stopPlaying() {
      webRTCAdaptor.stop(streamId);
    }

    function checkAndRepublishIfRequired() {
      var iceState = webRTCAdaptor.signallingState(streamId);
      if (
        iceState == null ||
        iceState == "failed" ||
        iceState == "disconnected"
      ) {
        console.log("Publish has stopped and will try to re-publish");
        webRTCAdaptor.stop(streamId);
        webRTCAdaptor.closePeerConnection(streamId);
        webRTCAdaptor.closeWebSocket();
        initWebRTCAdaptor(true, autoRepublishEnabled);
      }
    }

    function turnOffLocalCamera() {
      webRTCAdaptor.turnOffLocalCamera();
    }

    function turnOnLocalCamera() {
      webRTCAdaptor.turnOnLocalCamera();
    }

    function muteLocalMic() {
      webRTCAdaptor.muteLocalMic();
    }

    function unmuteLocalMic() {
      webRTCAdaptor.unmuteLocalMic();
    }

    function handleImageData(data) {
      imageReceiver.receiveDataChunk(data);

      if (imageReceiver.isAllDataReceived()) {
        var jsonHeader = JSON.parse(imageReceiver.headerText);

        var date = new Date(jsonHeader.messageDate);

        var bytes = new Uint8Array(imageReceiver.receivedData);
        var blob = new Blob([bytes.buffer]);
        console.log("Creating Image");
        var urlCreator = window.URL || window.webkitURL;
        var imageUrl = urlCreator.createObjectURL(blob);

        createImageMessage(imageUrl, false, date.toLocaleTimeString());
        imageReceiver.clear();
      }
    }

    function sendData(data) {
      try {
        var iceState = webRTCAdaptor.iceConnectionState(streamNameBox.value);
        if (
          iceState != null &&
          iceState != "failed" &&
          iceState != "disconnected"
        ) {
          webRTCAdaptor.sendData(streamNameBox.value, data);
        } else {
          alert("WebRTC connection is not active. Please click start first");
        }
      } catch (exception) {
        console.error(exception);
        alert(
          "Message cannot be sent. Make sure you've enabled data channel on server web panel"
        );
      }
    }

    function handleTextMessage(data) {
      var messageObj = JSON.parse(data);
      var dateObj = new Date(messageObj.messageDate);

      createNewMessage(
        messageObj.messageBody,
        dateObj.toLocaleTimeString(),
        false
      );
    }

    function initializeWebRTCAdaptor(mode) {
      if (mode == "publish") {
        webRTCAdaptor = new WebRTCAdaptor({
          websocket_url: websocketURL,
          mediaConstraints: mediaConstraints,
          peerconnection_config: pc_config,
          sdp_constraints: sdpConstraints,
          localVideoId: "localVideo",
          debug: true,
          bandwidth: 900,
          callback: function (info, obj) {
            if (info == "initialized") {
              console.log("initialized");
              start_button.disabled = false;
              stop_button.disabled = true;
            } else if (info == "publish_started") {
              //stream is being published
              console.log("publish started");
              start_button.disabled = true;
              stop_button.disabled = false;
              if (autoRepublishEnabled && autoRepublishIntervalJob == null) {
                autoRepublishIntervalJob = setInterval(() => {
                  checkAndRepublishIfRequired();
                }, 3000);
              }
            } else if (info == "publish_finished") {
              //stream is being finished
              console.log("publish finished");
              start_button.disabled = false;
              stop_button.disabled = true;
              imageSender.clear();
              imageReceiver.clear();
            } else if (info == "closed") {
              //console.log("Connection closed");
              if (typeof obj != "undefined") {
                console.log("Connecton closed: " + JSON.stringify(obj));
              }
            } else if (info == "pong") {
              //ping/pong message are sent to and received from server to make the connection alive all the time
              //It's especially useful when load balancer or firewalls close the websocket connection due to inactivity
            } else if (info == "refreshConnection") {
              checkAndRepublishIfRequired();
            } else if (info == "ice_connection_state_changed") {
              console.log("iceConnectionState Changed: ", JSON.stringify(obj));
            } else if (info == "updated_stats") {
              //obj is the PeerStats which has fields
              //averageOutgoingBitrate - kbits/sec
              //currentOutgoingBitrate - kbits/sec
              console.log(
                "Average outgoing bitrate " +
                  obj.averageOutgoingBitrate +
                  " kbits/sec" +
                  " Current outgoing bitrate: " +
                  obj.currentOutgoingBitrate +
                  " kbits/sec"
              );
            } else if (info == "data_received") {
              var data = obj.event.data;

              if (data instanceof ArrayBuffer) {
                handleImageData(data);
              } else if (data instanceof Blob) {
                data.arrayBuffer().then((buffer) => handleImageData(buffer));
              } else {
                handleTextMessage(data);
              }
            } else {
              console.log(info + " notification received");
            }
          },
          callbackError: function (error, message) {
            //some of the possible errors, NotFoundError, SecurityError,PermissionDeniedError

            console.log("error callback: " + JSON.stringify(error));
            var errorMessage = JSON.stringify(error);
            if (typeof message != "undefined") {
              errorMessage = message;
            }
            var errorMessage = JSON.stringify(error);
            if (error.indexOf("NotFoundError") != -1) {
              errorMessage =
                "Camera or Mic are not found or not allowed in your device";
            } else if (
              error.indexOf("NotReadableError") != -1 ||
              error.indexOf("TrackStartError") != -1
            ) {
              errorMessage =
                "Camera or Mic is being used by some other process that does not let read the devices";
            } else if (
              error.indexOf("OverconstrainedError") != -1 ||
              error.indexOf("ConstraintNotSatisfiedError") != -1
            ) {
              errorMessage =
                "There is no device found that fits your video and audio constraints. You may change video and audio constraints";
            } else if (
              error.indexOf("NotAllowedError") != -1 ||
              error.indexOf("PermissionDeniedError") != -1
            ) {
              errorMessage = "You are not allowed to access camera and mic.";
            } else if (error.indexOf("TypeError") != -1) {
              errorMessage = "Video/Audio is required";
            } else if (error.indexOf("ScreenSharePermissionDenied") != -1) {
              errorMessage = "You are not allowed to access screen share";
              $(".video-source").first().prop("checked", true);
            } else if (error.indexOf("WebSocketNotConnected") != -1) {
              errorMessage = "WebSocket Connection is disconnected.";
            }
            alert(errorMessage);
          },
        });
      } else if (mode == "play") {
        webRTCAdaptor = new WebRTCAdaptor({
          websocket_url: websocketURL,
          mediaConstraints: mediaConstraints,
          peerconnection_config: pc_config,
          sdp_constraints: sdpConstraints,
          remoteVideoId: "remoteVideo",
          isPlayMode: true,
          debug: true,
          candidateTypes: ["tcp", "udp"],
          callback: function (info, obj) {
            if (info == "initialized") {
              console.log("initialized");
              start_button.disabled = false;
              stop_button.disabled = true;
            } else if (info == "play_started") {
              //joined the stream
              console.log("play started");
              start_button.disabled = true;
              stop_button.disabled = false;
              webRTCAdaptor.getStreamInfo(streamId);
            } else if (info == "play_finished") {
              //leaved the stream
              console.log("play finished");
              start_button.disabled = false;
              stop_button.disabled = true;
              imageSender.clear();
              imageReceiver.clear();
            } else if (info == "closed") {
              //console.log("Connection closed");
              if (typeof obj != "undefined") {
                console.log("Connecton closed: " + JSON.stringify(obj));
              }
            } else if (info == "ice_connection_state_changed") {
              console.log("iceConnectionState Changed: ", JSON.stringify(obj));
            } else if (info == "data_received") {
              var data = obj.event.data;

              if (data instanceof ArrayBuffer) {
                handleImageData(data);
              } else if (data instanceof Blob) {
                data.arrayBuffer().then((buffer) => handleImageData(buffer));
              } else {
                handleTextMessage(data);
              }
            } else {
              console.log(info + " notification received");
            }
          },
          callbackError: function (error) {
            //some of the possible errors, NotFoundError, SecurityError,PermissionDeniedError

            console.log("error callback: " + JSON.stringify(error));
            alert(JSON.stringify(error));
          },
        });
      } else {
        webRTCAdaptor = new WebRTCAdaptor({
          websocket_url: websocketURL,
          mediaConstraints: mediaConstraints,
          peerconnection_config: pc_config,
          sdp_constraints: sdpConstraints,
          localVideoId: "localVideo",
          remoteVideoId: "remoteVideo",
          callback: function (info, obj) {
            if (info == "initialized") {
              console.log("initialized");
              start_button.disabled = false;
              stop_button.disabled = true;
            } else if (info == "joined") {
              //joined the stream
              console.log("joined");
              start_button.disabled = true;
              stop_button.disabled = false;
            } else if (info == "leaved") {
              //leaved the stream
              console.log("leaved");
              start_button.disabled = false;
              stop_button.disabled = true;
              imageSender.clear();
              imageReceiver.clear();
            } else if (info == "data_received") {
              var data = obj.event.data;

              if (data instanceof ArrayBuffer) {
                handleImageData(data);
              } else if (data instanceof Blob) {
                data.arrayBuffer().then((buffer) => handleImageData(buffer));
              } else {
                handleTextMessage(data);
              }
            }
          },
          callbackError: function (error) {
            //some of the possible errors, NotFoundError, SecurityError,PermissionDeniedError
            if ("data_channel_error" == error) {
              console.log("received data channel error");
            } else {
              console.log("error callback: " + error);
              alert(error);
            }
          },
        });
      }
    }

    var pc_config = {
      iceServers: [
        {
          urls: "stun:stun.l.google.com:19302",
        },
      ],
    };

    var sdpConstraints = {
      OfferToReceiveAudio: true,
      OfferToReceiveVideo: true,
    };
    var mediaConstraints = {
      video: true,
      audio: true,
    };

    var appName = location.pathname.substring(
      0,
      location.pathname.lastIndexOf("/") + 1
    );
    var websocketURL =
      "ws://" + location.hostname + ":5080" + appName + "websocket";

    if (location.protocol.startsWith("https")) {
      websocketURL =
        "wss://" + location.hostname + ":5443" + appName + "websocket";
    }

    var webRTCAdaptor = null;

    initializeWebRTCAdaptor(mode);
  </script>
</html>
